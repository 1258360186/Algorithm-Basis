##  831. KMP字符串

### 题目

给定一个模式串S，以及一个模板串P，所有字符串中只包含大小写英文字母以及阿拉伯数字。

模板串P在模式串S中多次作为子串出现。

求出模板串P在模式串S中所有出现的位置的起始下标。

### 输入格式

第一行输入整数N，表示字符串P的长度。

第二行输入字符串P。

第三行输入整数M，表示字符串S的长度。

第四行输入字符串S。

### 输出格式

共一行，输出所有出现位置的起始下标（下标从0开始计数），整数之间用空格隔开。

### 数据范围

$1≤N≤10^5$
$1≤M≤10^6$

### 输入样例

```
3
aba
5
ababa
```

### 输出样例

```
0 2
```

### AC代码

```c++
#include <iostream>

using namespace std;

int n,m;
char s[1000010],p[100010];
int ne[100010];


int main()
{
    cin >> n >> p+1 >> m >> s+1;
    for(int i=2,j=0;i<=n;i++)
    //j表示匹配成功的长度,i表示q数组中的下标,因为q数组的下标是从1开始的,ne[1]一定为0,所以i从2开始
    {
        while(j&&p[i]!=p[j+1]) j=ne[j];
        if(p[i]==p[j+1]) j++;
        ne[i]=j;
        //对应其下标
    }
    for(int i=1,j=0;i<=m;i++)
    {
        while(j&&s[i]!=p[j+1]) j=ne[j];
        //如果匹配不成功,则换到j对应的ne数组中的值
        if(s[i]==p[j+1]) j++;
        //匹配成功了,那么j就加1,继续后面的匹配
        if(j==n)//完全匹配上
        {
            cout << i-j << ' ';
            //因为题目中的下标从0开始,所以i-j不用+1;
            j=ne[j];
        }
    }
    return 0;
}
```

### 解题思路

>**KMP算法**