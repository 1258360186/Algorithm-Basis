##  848. 有向图的拓扑序列

### 题目

给定一个 $n$ 个点 $m$ 条边的有向图，点的编号是 $1$ 到 $n$，图中可能存在重边和自环。

请输出任意一个该有向图的拓扑序列，如果拓扑序列不存在，则输出 $−1$。

若一个由图中所有点构成的序列 $A$ 满足：对于图中的每条边 $(x,y)$，$x$ 在 $A$ 中都出现在 $y$ 之前，则称 $A$ 是该图的一个拓扑序列。

### 输入格式

第一行包含两个整数 $n$ 和 $m$。

接下来 $m$ 行，每行包含两个整数 $x$ 和 $y$，表示存在一条从点 $x$ 到点 $y$ 的有向边 $(x,y)$。

### 输出格式

共一行，如果存在拓扑序列，则输出任意一个合法的拓扑序列即可。

否则输出 $−1$。

### 数据范围

$1≤n,m≤10^5$

### 输入样例

```
3 3
1 2
2 3
1 3
```

### 输出样例

```
1 2 3
```

### AC代码

```c++
#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

int h[100010],e[100010],ne[100010],idx;
int d[100010];//存储节点的入度
int q[100010];//模拟队列
int n,m;

int add(int a,int b){//图的存储
    e[idx]=b;ne[idx]=h[a];h[a]=idx++;
}

bool topsort()
{
    int hh = 0, tt = -1;//初始化队头与队尾

    // 将最初的入度为零的点存入
    for (int i = 1; i <= n; i ++ )
        if (!d[i])
            q[ ++ tt] = i;

    while (hh <= tt)//队列不为空
    {
        int t = q[hh ++ ];//取队头，并删除

        for (int i = h[t]; i != -1; i = ne[i])
        {
            int j = e[i];//获取下个节点值
            if (-- d[j] == 0)//若删除当前节点的边后下个节点为入度为零的节点就存入队列
                q[ ++ tt] = j;
        }
    }

    // 如果所有点都入队了，说明存在拓扑序列；否则不存在拓扑序列。
    return tt == n - 1;
}


int main()
{
    cin >> n >>m;
    memset(h, -1, sizeof h);//初始化链接表
    for (int i = 0; i < m; i ++ ){
        int a,b;
        cin >> a >> b;
        add(a, b);
        d[b]++;//记录各节点入度
    }
    if(topsort()){//若存在则输出
        for (int i = 0; i < n; i ++ ){
            cout << q[i] << " ";
        }
    }else puts("-1");
    return 0;
}
```

### 解题思路

>**BFS+拓扑序列**

> 用队列来执行 ，初始化讲所有入度为0的顶点入队。
>
> 主要由以下两步循环执行，直到不存在入度为 0 的顶点为止
>
> 选择一个入度为 0 的顶点，并将它输出；
> 删除图中从顶点连出的所有边。
> 循环结束，
>
> 若输出的顶点数小于图中的顶点数，则表示该图存在回路，即无法拓扑排序，
>
> 否则，输出的就是拓扑序列 （不唯一）